# Практична робота №5

**Тема**: Помилки роботи з пам'яттю

## Варіант 14

```
Побудувати сценарій, у якому malloc повертає успіх для великого розміру, але процес завершується пізніше через OOM при записі в сторінки.
```

## Теоретичні відомості

У Linux використовується механізм overcommit пам'яті, за якого виклики виділення пам'яті (наприклад, malloc) можуть повертати успіх навіть тоді, коли фізично вільної пам'яті недостатньо.
Фактичне виділення фізичних сторінок відбувається лише при першому доступі до них (зазвичай при записі). Це реалізується через механізм demand paging та обробку page fault.
Якщо під час доступу до пам'яті система не може виділити нові сторінки (через нестачу RAM і swap), ядро активує механізм Out-Of-Memory killer (OOM-killer), який завершує один або кілька процесів для звільнення пам'яті.

## Хід роботи

Необхідного результату вкрай легко досягти на моєму тестовому пристрої - Raspberry Pi 3 Model B - оскільки він оснащений лише одним гігабайтом фізичної пам'яті (частину з якого від'їдає відеоядро), який дуже швидко вичерпується.
 
Було реалізовано програму, яка:
1. запитує великий обсяг пам'яті (8 ГБ при наявності лише 1 ГБ)
2. перевіряє успішність виділення
3. поступово записує у кожну сторінку пам'яті (із затримкою 5 мс кожні 64 сторінок)

Як результат, ми спостерігаємо заповнення усієї пам'яті пристрою та неминуче OOM вбивство процесу (Killed).

Для того, щоб гарантувати здійснення overcommit при malloc, потрібно перемикнути відповідний параметр ядра:

```sh
$ sudo sysctl -w vm.overcommit_memory=1
```

Інакше цілком ймовірно, що виклик malloc просто не пройде успішно.

Також критично важливо не використовувати swap, оскільки на старій Raspberry Pi це може призвести до зависання системи ще до OOM.

### Код

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define SIZE (8L * 1024L * 1024L * 1024L)

int main(void) {
        printf("Attempting to allocate %zuG...\n", SIZE / 1024 / 1024 / 1024);

        char *p = malloc(SIZE);
        if (!p) {
                fprintf(stderr, "malloc failed\n");
                return 1;
        }

        puts("malloc succeeded, writing to memory...");

        for (size_t i = 0; i < SIZE; i += 4096) {
                p[i] = 99;

                if ( (i / 4096) % 64 == 0 ) {
                        usleep(5000);
                }
        }

        puts("done");
        free(p);
        return 0;
}
```

### Компіляція та запуск

```sh
dietpi@DietPi:pr5$ make oc
cc     oc.c   -o oc
dietpi@DietPi:pr5$ ./oc
Attempting to allocate 8G...
malloc succeeded, writing to memory...
Killed
dietpi@DietPi:pr5$
```

# Висновки

У ході роботи було досліджено механізм управління пам'яттю в Linux та експериментально підтверджено:

1. наявність механізму overcommit
2. відкладене виділення фізичної пам'яті
3. роботу OOM-killer при вичерпанні пам'яті

Отримані результати демонструють реальну поведінку підсистеми керування пам'яттю Linux на пристроях з обмеженими ресурсами та можуть бути використані для подальшого аналізу та оптимізації програм, що працюють із великими обсягами пам'яті.
